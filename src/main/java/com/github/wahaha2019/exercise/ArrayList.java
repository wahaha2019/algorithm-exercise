/*
 * This Java source file was generated by the Gradle 'init' task.
 */

package com.github.wahaha2019.exercise;

import java.io.Serializable;
import java.util.Arrays;

/**
 * <tt>ArrayList</tt> is not thread safe. elements can be null.
 */
public class ArrayList<E> implements Serializable {
  private static final long serialVersionUID = 5810606339357346347L;
  private static final int DEFAULT_CAPACITY = 256;
  private transient final double expendRatio = 1.382D;
  private transient final int expendStep = 8;
  protected transient Object[] data;
  protected int size;

  /**
   * Create a new <tt>ArrayList</tt> with an integer serial that start from 0, this method is used for testing.
   *
   * @param size The size of the new <tt>ArrayList</tt>.
   * @return A new <tt>ArrayList</tt>.
   */
  static ArrayList<Integer> newIntSerial(int size) {
    ArrayList<Integer> list = new ArrayList<>(size);
    fillIntSerial(size, list);
    return list;
  }

  /**
   * Fill the internal array with an integer serial that start from 0
   *
   * @param size The size of the integer serial.
   * @param list The <tt>ArrayList</tt> which to fill with.
   */
  static void fillIntSerial(int size, ArrayList list) {
    list.setSize(size);
    for (int i = 0; i < size; i++) {
      list.data[i] = i;
    }
  }

  /**
   * Fill the internal array with an integer serial with given params.
   * @param begin The first value of the serial.
   * @param step The step of the serial.
   * @param size The size of the serial.
   * @param list The <tt>ArrayList</tt> which to fill with.
   */
  static void fillIntSerial(int begin, int step, int size, ArrayList list) {
    if (step <= 0) {
      throw new IllegalArgumentException("step must greater than 0");
    }
    long max = step * size + begin;
    if (max > Integer.MAX_VALUE) {
      throw new IllegalArgumentException("integer overflowed.");
    }
    list.setSize(size);
    for (int i = 0; i < size; i++) {
      list.data[i] = begin + i * step;
    }
  }

  /**
   * Create a new <tt>ArrayList</tt> with the given initial capacity.
   * @param capacity The initial capacity.
   */
  public ArrayList(int capacity) {
    if (capacity <= 0) {
      throw new IllegalArgumentException("List capacity must greater than 0");
    }
    data = new Object[capacity];
    size = 0;
  }

  /**
   * Create a new <tt>ArrayList</tt> with given capacity.
   */
  public ArrayList() {
    this(DEFAULT_CAPACITY);
  }

  /**
   * @return If the ArrayList is empty.
   */
  public boolean isEmpty() {
    return size == 0;
  }

  /**
   * @return If the ArrayList is full.
   */
  public boolean isFull() {
    return size == getCapacity();
  }

  /**
   * @return The elements count of this list.
   */
  public int getSize() {
    return size;
  }

  /**
   * Trim or grow the list to given size. When grow, fill null in all new added element space.
   * @param newSize The new Size.
   */
  public void setSize(final int newSize) {
    if (newSize < 0) {
      throw new IllegalArgumentException("List size must greater than 0");
    }
    if (newSize == 0) {
      clear();
      return;
    }
    if (newSize > getCapacity()) {
      Object[] newData = new Object[newSize];
      for (int i = 0; i < size; i++) {
        newData[i] = data[i];
        data[i] = null;
      }
      data = newData;
    } else {
      for (int i = newSize; i < size; i++) {
        data[i] = null;
      }
    }
    size = newSize;
  }

  /**
   * Clear this list.
   */
  public void clear() {
    for (int i = 0; i < size; i++) {
      data[i] = null;
    }
    size = 0;
  }

  /**
   * @return The capacity of this list.
   */
  public int getCapacity() {
    return data.length;
  }

  /**
   * Get element at given index.
   * @param i The index.
   * @return The element.
   */
  public E get(int i) {
    checkIndex(i);
    return (E) data[i];
  }

  /**
   * Set element at given index.
   * @param i The index.
   * @param ele The element.
   */
  public void set(int i, E ele) {
    checkIndex(i);
    data[i] = ele;
  }

  /**
   * Insert an element before given index.
   * @param i The index.
   * @param ele The element.
   */
  public void insert(int i, E ele) {
    if (size == 0) {
      if (i != 0) {
        throw new IllegalArgumentException("Index must be 0 when insert to an empty list.");
      }
    } else {
      checkIndex(i);
    }
    if (i == Integer.MAX_VALUE || size == Integer.MAX_VALUE) {
      throw new IllegalArgumentException("List size is max, can not insert any more.");
    }
    if (size + 1 <= getCapacity()) {
      for (int j = size - 1; j >= i; j--) {
        data[j + 1] = data[j];
      }
      data[i] = ele;
    } else {
      long newCapacity = Math.round(getCapacity() * expendRatio);
      if (newCapacity <= getCapacity()) {
        newCapacity += expendStep;
      }
      if (newCapacity > Integer.MAX_VALUE) {
        newCapacity = Integer.MAX_VALUE;
      }
      Object[] newData = new Object[(int) newCapacity];
      for (int j = i; j < size; j++) {
        newData[j + 1] = data[j];
        data[j] = null;
      }
      newData[i] = ele;
      for (int j = 0; j < i; j++) {
        newData[j] = data[j];
        data[j] = null;
      }
      data = newData;
    }
    size++;
  }

  /**
   * Remove an element at given index.
   * @param i The index.
   */
  public void delete(int i) {
    checkIndex(i);
    for (int j = i; j < size - 1; j++) {
      data[j] = data[j + 1];
    }
    data[size - 1] = null;
    size--;
  }

  /**
   * Append an element after the end of this list.
   * @param ele The element.
   */
  public void append(E ele) {
    if (getCapacity() == Integer.MAX_VALUE) {
      throw new IllegalArgumentException("List size is max, can not append any more.");
    }
    setSize(size + 1);
    data[size - 1] = ele;
  }

  /**
   * Delete all elements from first to given index (include).
   * @param i The index.
   */
  public void deleteToTop(int i) {
    checkIndex(i);
    int diff = i + 1;
    int limit = size - diff;
    for (int j = 0; j < limit; j++) {
      data[j] = data[j + diff];
    }
    for (int j = limit; j < size; j++) {
      data[j] = null;
    }
    size = limit;
  }

  /**
   * Delete all elements from last to given index (include).
   * @param i The index.
   */
  public void deleteToEnd(int i) {
    checkIndex(i);
    for (int j = i; j < size; j++) {
      data[j] = null;
    }
    size = i;
  }

  /**
   * Check if index is valid.
   * @param i
   */
  private void checkIndex(int i) {
    if (i >= size || i < 0) {
      throw new ArrayIndexOutOfBoundsException("size is " + size + "; index is " + i);
    }
  }

  @Override
  public boolean equals(Object obj) {
    if (obj == null) {
      return false;
    }
    if (!(obj instanceof ArrayList)) {
      return false;
    }
    ArrayList other = (ArrayList) obj;
    if (this.size != other.size) {
      return false;
    } else if (this.size - other.size == 0) {
      return true;
    }
    for (int i = 0; i < size; i++) {
      if (this.data[i] == null) {
        if (other.data[i] != null) {
          return false;
        }
      } else if (!this.data[i].equals(other.data[i])) {
        return false;
      }
    }
    return true;
  }

  @Override
  public int hashCode() {
    int result = 1;
    for (int i = 0; i < size; i++) {
      result = 31 * result + (data[i] == null ? 0 : data[i].hashCode());
    }
    result = 31 * result + size;
    return result;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder(64);
    sb.append("ArrayList{size=");
    sb.append(size);
    sb.append(",");
    sb.append("data={");
    for (int i = 0; i < size; i++) {
      sb.append(data[i]);
      if (i < size - 1) {
        sb.append(',');
      }
    }
    sb.append("}}");
    return sb.toString();
  }

  /**
   * Returns a shallow copy of this <tt>ArrayList</tt> instance.  (The elements themselves are not copied.)
   * @return a clone of this <tt>ArrayList</tt> instance
   */
  @Override
  public ArrayList<E> clone() {
    ArrayList copy = new ArrayList();
    copy.size = size;
    copy.data = Arrays.copyOf(data, size);
    return copy;
  }

  private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException {
    s.defaultWriteObject();
    for (int i = 0; i < size; i++) {
      s.writeObject(data[i]);
    }
  }

  private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException {
    s.defaultReadObject();
    if (size > 0) {
      data = new Object[size];
      for (int i = 0; i < size; i++) {
        data[i] = s.readObject();
      }
    }
  }
}
